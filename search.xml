<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6</title>
      <link href="/2020/09043.html"/>
      <url>/2020/09043.html</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript的组成："><a href="#JavaScript的组成：" class="headerlink" title="JavaScript的组成："></a>JavaScript的组成：</h3><p><strong>ECMAScript**</strong>是一种由Ecma国际(前身为欧洲计算机制造商协会**,英文名称是（European Computer Manufacturers Association)通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是javascript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。</p><p><strong>BOM</strong>（Browser Object Model）<strong>是指浏览器对象模型</strong>，它使 JavaScript 有能力与浏览器进行“对话”。浏览器对象模型是Window对象。</p><p><strong>DOM</strong> （Document Object Model）<strong>是指文档对象模型</strong>，通过它，可以访问HTML文档的所有元素。文档对象模型HTML Document 对象。</p><h3 id="1、javaScript组成的介绍："><a href="#1、javaScript组成的介绍：" class="headerlink" title="1、javaScript组成的介绍："></a>1、javaScript组成的介绍：</h3><blockquote><p>包括：ECMAScript,DOM,BOM</p><p>1.ECMAScript:javascript核心语法，不依赖平台</p><p>例如：定义变量，if,switch,for,数组Api,字符串API,正则Api…</p><p>2.DOM:(Document Object Model)针对浏览器标签操作 例如：获取id，获取类名，获取标签名<br>注：操作真实DOM，引起重绘和回流–&gt;才引出虚拟DOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  重绘：主要指页面颜色的改变，不影响DOM的空间变化 color,background</span><br><span class="line">  回流：指页面元素的尺寸(width,padding,height,margin)，位置的变化:left,top,bottom,right等</span><br><span class="line">  </span><br><span class="line">    tranform:translateX(300px)</span><br><span class="line">  </span><br><span class="line">  重绘未必引起回流，但回流一定引起重绘</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p>3.BOM:(Browser Object Model)主要针对浏览器相关API的操作</p><p>history: history.go(),history.back() pusState,popState,replaceState<br>navigator:跟浏览器系统信息相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   navigator.userAgent</span><br><span class="line">   </span><br><span class="line"> 参考：https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Navigator    location:主要获取浏览器地址栏相关的信息</span><br><span class="line">   location.search    location.href    location.hash</span><br><span class="line"></span><br><span class="line">参考：https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Location</span><br><span class="line">123456</span><br></pre></td></tr></table></figure></blockquote><p><strong>ECMA6/7/8…新增特性</strong><br>ES6 ES2015 … ES11 ES2020</p><p>了解ES6/7/8/9/最新进展：<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">https://github.com/tc39/proposals/blob/master/finished-proposals.md</a></p><p><strong>let和const: 重点</strong></p><blockquote><p>let 定义变量<br>const 定义常量<br>面试官： 1.你说一下let和var的区别</p></blockquote><p><strong>相同点：都是定义变量</strong></p><blockquote><p>区别：<br>1.是否有变量提升 var有变量提升，let没有<br>2.是否能重复定义 var允许重复定义变量，let不允许重复定义<br>3.是否有块级作用域 { }<br>全局作用域：在函数外部定义的范围<br>局部作用域：在函数内部定义的范围<br>块级作用域：在{ }大括号中定义范围</p></blockquote><h3 id="2-你说一下let和const的区别"><a href="#2-你说一下let和const的区别" class="headerlink" title="2.你说一下let和const的区别"></a>2.你说一下let和const的区别</h3><blockquote><p>let 定义变量 const 定义常量,是不能修改的，如果要修改，将常量定义成对象的形式，这样，就可以给对象中的属性进行修改<br>symbol：是ES6新增的基本数据类型<br>number,string,boolean,null,undefined,symbol(ES6新增)</p><p>symbol:定义的值是唯一性</p></blockquote><p><strong>两个symbol类型的值永远不等</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">var s1&#x3D;Symbol()</span><br><span class="line">var s2&#x3D;Symbol()</span><br><span class="line">s1&#x3D;&#x3D;&#x3D; s2</span><br><span class="line"> false</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><h3 id="3-扩展运算符-…"><a href="#3-扩展运算符-…" class="headerlink" title="3.扩展运算符( … )"></a>3.扩展运算符( … )</h3><p>扩展运算符（也称展开操作符）两层作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.将数组转换成数据列表 [a,b,c,d]---&gt;a,b,c,d</span><br><span class="line">例如：</span><br><span class="line">var arr1&#x3D;[666,777,888]</span><br><span class="line">var arr2&#x3D;[&#39;hello&#39;,&#39;vuejs&#39;]</span><br><span class="line">var result&#x3D;[...arr1,...arr2]</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p><strong>（1）.将数据列表转换成数组 a,b,c,d—&gt;[a,b,c,d]</strong></p><p><strong>（2）.展开对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var result&#x3D;&#123;...obj1,...obj2&#125;</span><br><span class="line">或</span><br><span class="line">result&#x3D;Object.assign(&#123;&#125;,obj1,obj2)</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">function sum1(str,...args) &#123;</span><br><span class="line">  var result&#x3D;0;</span><br><span class="line">  for(var i&#x3D;0;i&lt;args.length;i++) &#123;</span><br><span class="line">    result+&#x3D;args[i]</span><br><span class="line">  &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum1(&#39;请输入&#39;,20,30,40)</span><br><span class="line">class类</span><br><span class="line">定义一个类：</span><br><span class="line">class Person &#123;</span><br><span class="line">   constructor(a,b) &#123;</span><br><span class="line">     &#x2F;&#x2F;构造器</span><br><span class="line">     this.属性&#x3D;a</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  方法1() &#123;&#125;</span><br><span class="line">  方法2() &#123;&#125;</span><br><span class="line">  方法3() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">继承一个类：</span><br><span class="line">class Child extends Person &#123;</span><br><span class="line"></span><br><span class="line">   constructor(a,b) &#123;</span><br><span class="line">     super()  &#x2F;&#x2F;代表父类</span><br><span class="line">     &#x2F;&#x2F;构造器</span><br><span class="line">     this.属性&#x3D;a</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  方法1() &#123;&#125;</span><br><span class="line">  方法2() &#123;&#125;</span><br><span class="line">  方法3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142</span><br></pre></td></tr></table></figure><h3 id="4-set和map"><a href="#4-set和map" class="headerlink" title="4.set和map:"></a>4.set和map:</h3><p>（1）<strong>set:理解成是一个不重复的数组</strong></p><p>将set类型的数据转换成数组：</p><blockquote><p>var s=new Set() Array.from(s) 或[…s]</p><p>var s=new Set() s.add() s.has() s.delete() s.size</p></blockquote><p><strong>例如：数组去重：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[3,34,23,2,2,23,23,3,34,34,34,45]</span><br><span class="line"></span><br><span class="line">[...new Set(arr)]</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>（2）<strong>map:理解成是一个对象,增强了对象key的数据类型，以前只能是字符串，现在对象的属性可以是做任意的数据类型！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&#39;jack&#39;,</span><br><span class="line">  &#39;10&#39;:&#39;abc&#39;,</span><br><span class="line">  &#39;undefined&#39;:999</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m1&#x3D;new Map()</span><br><span class="line">m1.set(属性名,值) &#x2F;&#x2F;设置</span><br><span class="line">m1.get(属性名)  &#x2F;&#x2F;获取</span><br><span class="line">m1.delete(属性名)  &#x2F;&#x2F;删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历Map类型获取所有值</span><br><span class="line">for(var [key,value] of m1) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(key)</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure><h3 id="5-Promise：重点"><a href="#5-Promise：重点" class="headerlink" title="5.Promise：重点"></a>5.Promise：重点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1.用于处理回调地狱的异步解决方案</span><br><span class="line">具体实现：</span><br><span class="line">function waiting() &#123;</span><br><span class="line"></span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    </span><br><span class="line">             setTimeout(function() &#123;</span><br><span class="line">      </span><br><span class="line">                &#x2F;&#x2F;console.log(2)</span><br><span class="line">                reject(&#39;哈哈&#39;)</span><br><span class="line">    </span><br><span class="line">            &#125;,2000)      </span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waiting().then(res&#x3D;&gt;&#123;</span><br><span class="line">   console.log(1)</span><br><span class="line">   console.log(&#39;res:&#39;,res)</span><br><span class="line">    console.log(3)</span><br><span class="line"></span><br><span class="line">&#125;).catch(error&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">   console.log(&#39;error:&#39;,error)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.then</span><br><span class="line">.catch</span><br><span class="line">.race</span><br><span class="line">.finally</span><br><span class="line">Promise.all([waiting(),waiting2(),waiting3()])</span><br><span class="line">   .then(res&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;).catch(res&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940</span><br></pre></td></tr></table></figure><h3 id="6-async-await-ES2017-重点"><a href="#6-async-await-ES2017-重点" class="headerlink" title="6.async/await(ES2017) 重点"></a><strong>6.async/await(ES2017) 重点</strong></h3><p><strong>串行执行：必须先执行第一个异步，将第一个异步的结果返回传递给第二个</strong><br><strong>异步函数，再执行第二个异步的操作过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个函数</span><br><span class="line">function waiting() &#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">          &#x2F;&#x2F;我这里只是用setTimeout来模拟axios,</span><br><span class="line">             setTimeout(function() &#123;</span><br><span class="line">                resolve(&#39;第二个接口返回&#39;)</span><br><span class="line">            &#125;,2000)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F;第二个函数</span><br><span class="line">function waiting2() &#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">          &#x2F;&#x2F;我这里只是用setTimeout来模拟axios,</span><br><span class="line">             setTimeout(function() &#123;</span><br><span class="line">                reject(&#39;第二接口返回&#39;)</span><br><span class="line">            &#125;,2000)</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">async function handleFn() &#123;</span><br><span class="line">   console.log(1)</span><br><span class="line">   &#x2F;&#x2F;串行执行，先等待第一个函数返回</span><br><span class="line">    let res&#x3D;await waiting()</span><br><span class="line">    console.log(&#39;res:&#39;,res)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;再等待第二个函数返回</span><br><span class="line">    let res2&#x3D;await waiting2(res)</span><br><span class="line">    console.log(res2)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">并行：两个接口同时执行</span><br><span class="line">function waiting() &#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">          &#x2F;&#x2F;我这里只是用setTimeout来模拟axios,</span><br><span class="line">             setTimeout(function() &#123;</span><br><span class="line">                resolve(&#39;第二个接口返回&#39;)</span><br><span class="line"></span><br><span class="line">            &#125;,2000)</span><br><span class="line">     </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function waiting2() &#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">          &#x2F;&#x2F;我这里只是用setTimeout来模拟axios,</span><br><span class="line">             setTimeout(function() &#123;</span><br><span class="line">                reject(&#39;第二接口返回&#39;)</span><br><span class="line"></span><br><span class="line">            &#125;,2000)</span><br><span class="line">     </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">async function handleFn() &#123;</span><br><span class="line">   console.log(1)</span><br><span class="line">    &#x2F;&#x2F;并发执行，waiting(),waiting2()两个接口都成功返回才返回结果</span><br><span class="line">    let res&#x3D;await Promise.all([waiting(),waiting2()])</span><br><span class="line">     console.log(&#39;res:&#39;,res)</span><br><span class="line">     console.log(&#39;end&#39;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> handleFn().catch(res&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">     console.log(&#39;error:&#39;,res)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高阶综合面试题</title>
      <link href="/2020/09032.html"/>
      <url>/2020/09032.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Promise是什么？"><a href="#1-Promise是什么？" class="headerlink" title="1.Promise是什么？"></a>1.Promise是什么？</h3><ul><li>Promise是一种用于解决异步问题的思路、方案或者对象方式。</li></ul><h3 id="2-Promise怎么用？"><a href="#2-Promise怎么用？" class="headerlink" title="2.Promise怎么用？"></a>2.Promise怎么用？</h3><ul><li>Promise是一个对象，所以先用new的方式创建一个，然后给它传一个函数作为参数，这个函数有两个参数，一个叫reolve,另一个叫reject、 紧接着，就用then来进行调用</li></ul><h3 id="3-Promise原理"><a href="#3-Promise原理" class="headerlink" title="3.Promise原理"></a>3.Promise原理</h3><ul><li>在Promise内部，有一个状态管理器的存在，有三种状态: pending、fulfilled、rejected<br>(1) promise初始化状态为pending<br>(2) 当前调用resolve(成功), 会由pending =&gt; fulfilled<br>(3) 当调用reject(失败), 会由pending =&gt; rejected</li></ul><h3 id="4-跨域"><a href="#4-跨域" class="headerlink" title="4.跨域"></a>4.跨域</h3><p> <strong>什么是跨域</strong></p><p>协议、端口和域名不一致导致的跨域 跨域是因为浏览器需要遵守同源策略，发出的请求即使相应成功，也被浏览器拦截下来</p><p> <strong>同源策略</strong></p><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互、这是一个用于隔离潜在恶意文件的重要安全机制、</p><p> <strong>为什么</strong></p><p>如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。<a href="https://link.zhihu.com/?target=https://celverbamboo.github.io/2019/08/19/%25E5%25A6%2582%25E4%25BD%2595%25E9%2598%25B2%25E6%25AD%25A2%25E8%25B7%25A8%25E7%25AB%2599%25E6%2594%25BB%25E5%2587%25BB-XSS%25E5%2592%258CCSRF/">转送门</a> 1、 防御 XSS 攻击 XSS，即 Cross Site Script，中译是跨站脚本攻击。 <em>HttpOnly Cookie。</em> 输入过滤。 <em>服务器输出编码。</em>WAF(Web Application Firewall)</p><p>2、防御 CSRF 攻击 CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p><ul><li>关键操作只接口POST请求，服务器拒绝GET请求</li><li>验证码</li><li>Referer Check</li><li>Token验证</li></ul><h3 id="5-跨域的解决方案"><a href="#5-跨域的解决方案" class="headerlink" title="5.跨域的解决方案"></a>5.跨域的解决方案</h3><p>1、通过jsonp跨域 2、document.domain + iframe跨域 3、location.hash + iframe 4、window.name + iframe跨域 5、postMessage跨域 6、跨域资源共享(CORS) 7、nginx代理跨域 8、nodejs中间代理跨域 9、WebSocket协议跨域</p><h3 id="6-jsonp原理"><a href="#6-jsonp原理" class="headerlink" title="6.jsonp原理"></a>6.jsonp原理</h3><p>jsonp的核心则是动态添加 <strong>script</strong> 标签调用服务器提供的js脚本，允许用户传递一个callback参数给服务器，然后服务器返回数据时会将这个callback参数作为函数名老包裹JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了</p><ul><li>仅支持GET方法</li></ul><h3 id="7-如何进行网站性能优化"><a href="#7-如何进行网站性能优化" class="headerlink" title="7.如何进行网站性能优化"></a>7.如何进行网站性能优化</h3><p>1、Content方面 * 减少HTTP请求：合并文件、CSS精灵、inline image * 减少DNS查询： DNS查询完之前浏览器不能从这个主机下载任何文件、方法：DNS缓存、讲资源分布到恰当的数量的主机名，平衡并行下载和DNS查询 * 避免重定向 ： 多余的中间访问 * 使用AJAX缓存，真相跟 HTTP缓存没有什么区别。<a href="https://link.zhihu.com/?target=http://jinyanhuan.github.io/2015/12/23/ajax-caching/">相关链接</a> * 非必须组件延迟加载 * 未来所需组件预加载 * 减少DOM元素数量 * 将资源放到不同的域下面：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 * 减少iframe数量 * 不要404</p><p>2、Server方面 * 使用CDN * 添加Expires或者Cache-Control： 当Cache-Control和Expires同时存在时，Cache-Control会覆盖Expires。<a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000014669345">相关链接</a> * 使用Gzip压缩 * 配置Etag * Flush Buffer Early * Ajax使用GET进行请求 * 避免空src的img标签</p><p>3、Cookie方面 * 减小Cookie * 引入资源的域名不要包含cookie</p><p>4、CSS方面 * 将样式表放到顶部 * 不要使用CSS表达式 * 不使用@import * 不使用IE的Filter</p><p>5、JavaScript * 将脚本放到页面的底部 * 将JavaScript和CSS从外部引入 * 压缩JavaScript和CSS * 删除不需要的脚本 * 减少DOM的查询 * 合理设计事件监听器</p><p>6、图片方面 1. 优化图片： 根据实际颜色需要选择色深、压缩 2. 优化CSS精灵 3. 不要在HTML中拉伸图片 4. 保证favicon、ico小并且可缓存</p><p>7、移动方面 * 保证组件小于25K * Pack Components into a Multipart Document</p><h3 id="8-从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><a href="#8-从浏览器地址栏输入url到显示页面的步骤-以HTTP为例" class="headerlink" title="8.从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)"></a>8.从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</h3><p>大概流程 * URL输入 * DNS解析 * TCP连接 * 发送HTTP请求 * 服务器处理请求 * 服务器响应请求 * 浏览器解析渲染页面 * 连接结束</p><p>1、在浏览器数地址栏输入URL</p><p>2、浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜(即是有没有过期的意思)，跳转到转码步骤 * 如果资源未缓存，发起新请求 * 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 * 检验新鲜通常有两个HTTP头进行控制 <code>Expires</code> 和 <code>Cache-Control</code> - HTTP1.0提供Expires，值为一个绝对值表示<br>- HTTP1.1增加了Cache-Control : max-age=，值为以秒为单位的最大新鲜时间</p><p>3、浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p><p>4、浏览器<strong>组装一个HTTP(GET)请求报文</strong></p><p>5、浏览器<strong>获取主机ip地址</strong>，过程如下： * 浏览器缓存 * 本机缓存 * hosts文件 * 路由器缓存 * ISP DNS缓存 * DNS递归查询(可能存在负载均衡导致每次IP不一样)</p><p>6、<strong>打开一个sokcet与目标地址端口建立TCP链接，</strong> 三次握手如下： * 客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口 * 服务器发送<strong>SYN=1，ACK=X+1，Seq=Y</strong>的响应包<br>* 客户端发送<strong>ACK=Y+1，Seq=Z</strong></p><p>7、TCP链接建立后<strong>发送HTTP请求</strong></p><p>8、服务器接受请求并解析，将请求转发到服务程序，如虚拟机使用HTTP Host头部判断请求的服务程序</p><p>9、服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p><p>10、处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p><p>11、服务器将<strong>响应报文通过TCP链接发送回浏览器</strong></p><p>12、浏览器接受HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：</strong> * 主动发送<strong>Fin=1，Ack=Z，Seq=X报文</strong> * 被动发送<strong>ACK=X+1，Seq=Z报文</strong> * 被动发送<strong>Fin=1，ACK=X，Seq=Y报文</strong> * 主动发送<strong>ACK=Y，Seq=X报文</strong></p><p>13、浏览器检查响应状态码：是否为1XX、3XX、4XX、5XX，这些情况处理与2XX不同</p><p>14、如果资源可缓存，<strong>进行缓存</strong></p><p>15、对响应进行<strong>解码</strong>(例如gzip压缩)</p><p>16、根据资源类型决定如何处理(假设资源为HTML文档)</p><p>17、<strong>解析HTML文档、构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p><p>18、<strong>构建DOM树：</strong> <em>Tokenizing： 根据HTML规范将字符流解析为标记</em> Lexing：词法分析将标记转换为对象并定义属性和规则 * DOM construction： 根据HTML标记关系将对象组成DOM树</p><p>19、解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p><p>20、<strong>构建CSSOM树</strong> <strong>*Tokenizing</strong>： 字符流转换为标记流* <strong>Node</strong>：根据标记创建节点 * <strong>CSSOM</strong>：节点创建CSSOM树</p><p>21、<strong>根据DOM树和CSSOM树构建渲染树</strong>: <em>从DOM树的根节点遍历所有*</em>可见节点*<em>，不可见节点包括：1）script，meta这样本身不可见的标签。2)被CSS隐藏的节点，入display:none</em> 对每一个可节点，找到恰当的CSSOM规则并应用 * 发布可视节点的内容和计算样式</p><p>22、<strong>js解析如下</strong> <em>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时*</em>document.readystate为loading*** HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或者外部脚本。这些脚本同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常定义为函数和注册事件处理事件，他们可以遍历和操作script和他们之前的文档内容。</strong> <em>当解析器遇到设置了*</em>async属性<strong>的script时，开始下载脚本并继续解析文档。脚本在它</strong>下载完成后尽快执行<strong>，但是</strong>解析器不会停下来等它下载<strong>。</strong>异步脚本禁止使用document.write()<strong>，它们可以访问自己script和之前的文档元素* 所有<strong>deter</strong>脚本会<strong>按照在文档上出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档时</strong>，禁止使用document.write() *浏览器\</strong>在Document对象上触发DOMContentLoaded事件*** 此时文档完成解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成和执行</strong>，document.readState变为complete,window触发load事件</p><p>23、<strong>显示页面</strong>(HTML解析过程中会逐步显示页面)</p><h3 id="9-移动端开发自适应页面如何做？"><a href="#9-移动端开发自适应页面如何做？" class="headerlink" title="9.移动端开发自适应页面如何做？"></a>9.移动端开发自适应页面如何做？</h3><p>1、通过meta标签设置viewport，移动端的理想适口。 * <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code></p><p>2、设置rem单位来进行适配、加上Flex布局、百分比布局</p><p>3、其它方案，响应式适配、vw+rem</p><h3 id="10-rem原理"><a href="#10-rem原理" class="headerlink" title="10.rem原理"></a>10.rem原理</h3><ul><li>rem是是指相对于根元素的字体大小的单位</li><li>比如设置html font-size=100px;那么1rem=100px;之后的所有元素都可以用这个基准值来设置大小；</li><li><strong>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小——MDN</strong></li></ul><h3 id="11-说一下this。-相关链接"><a href="#11-说一下this。-相关链接" class="headerlink" title="11.说一下this。 相关链接"></a>11.说一下this。 <a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000008400124">相关链接</a></h3><p>与我们常见的很多语言不同，JavaScript 函数中的 this 指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，<strong>函数的调用方式决定了 this 指向。</strong> <em>直接调用 直接调用，就是通过 函数名(…) 这种方式调用</em> 方法调用 方法调用是指通过对象来调用其方法函数，它是 <strong>对象.方法函数(…)</strong> 这样的调用形式 <em>new关键字调用</em> 通过 bind() 将函数绑定到对象之后再进行调用 * 通过 call()、apply() 进行调用</p><h3 id="12-箭头函数的特点"><a href="#12-箭头函数的特点" class="headerlink" title="12.箭头函数的特点?"></a>12.箭头函数的特点?</h3><p>官方解释：箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<strong>this，arguments，super</strong>或 <strong>new.target。</strong></p><ul><li>引用箭头函数有两个方面的作用：更简短函数和并且不绑定<strong>this</strong></li><li>箭头函数不会创建this，它只会从自己的作用域链上一层继承this。</li><li>简而言之，箭头函数，永远指向当前调用的对象</li></ul><h3 id="13-和-的区别？"><a href="#13-和-的区别？" class="headerlink" title="13.== 和 === 的区别？"></a>13.== 和 === 的区别？</h3><ul><li>== 会进行隐式转换，比较前将两个被比较的值转换为相同类型。然后比较两个值是否相等</li><li>=== 不进行隐式转换，会比较类型和值</li></ul><h3 id="14-CSS选择器优先级"><a href="#14-CSS选择器优先级" class="headerlink" title="14.CSS选择器优先级"></a>14.CSS选择器优先级</h3><ul><li>每个选择器都有权值，权值越大越优先</li><li>继承的样式优先级低于自身制定样式</li><li>!important优先级最高，js也无法修改</li><li>权值相同的时候，靠近元素的样式优先级搞，顺序为内联样式 &gt; 内部样式表 &gt; 外部样式表</li></ul><h3 id="15-BFC"><a href="#15-BFC" class="headerlink" title="15.BFC"></a>15.BFC</h3><p><strong>什么是BFC</strong></p><p>BFC就是”块级格式化上下文”的意思，创建了BFC的元素就是一个独立的盒子，不过只有Block-level Box 可以参与创建BFC，它规定了内部的Block-level Box如何布局，并且与这个独立盒子里的布局不受外部影响，当然它不会影响到外面的元素。</p><p><strong>BFC特性：</strong></p><ul><li>内部的Box会在垂直方向，从顶部开始一个接一个地放置</li><li>Box垂直方向的距离由margin决定。<strong>属于同一个BFC的两个相邻Box的margin会发生叠加</strong></li><li>每个元素的margin box的左边，与包含的 border box 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。</li><li>BFC的区域不会与float box叠加</li><li>BFC就是页面的一个隔离的独立容器，容器里面的子元素不会受影响到外面的元素，反之亦然。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ul><h3 id="16-如何触发BFC"><a href="#16-如何触发BFC" class="headerlink" title="16.如何触发BFC"></a>16.如何触发BFC</h3><ul><li>根元素或包含根元素的元素</li><li>浮动元素,float 除了 none 以外</li><li>绝对定位元素, position 为 absolute、fixed</li><li>display 为 inline-block、table-cell、table-caption、flow-root</li><li>overflow 值不为 visible 的元素</li><li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li><li>网格元素 (display 为 grid 或 inline-grid 元素的直接子元素)</li><li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li><li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）</li></ul><h3 id="17-EventBus如何实现？相关链接"><a href="#17-EventBus如何实现？相关链接" class="headerlink" title="17.EventBus如何实现？相关链接"></a>17.EventBus如何实现？<a href="https://link.zhihu.com/?target=https://www.google.com/search?ei=lxMwXbq1I9GtoATPhYiwCQ&q=%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258FEventBus&oq=%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258FEventBus&gs_l=psy-ab.3..0i7i30.2995.4118..4267...0.0..0.175.1471.2j10......0....1..gws-wiz.......35i304i39j0i13j0.n6-ujhtDNPI&ved=&uact=5">相关链接</a></h3><p>利用发布/订阅模式，发布/订阅模式由一个发布者、多个订阅者以及一个调度中心所组成。订阅者们先在调度中心订阅某一事件并注册相应的回调函数，当某一个时刻发布者发布了一个事件,调度中心取出订阅了该事件的订阅者们所注册的回调函数来执行。</p><p>在发布/订阅模式中，订阅者和发布者并不需要关心对方的状态，订阅者只管订阅事件并注册回调、发布者只管发布事件，其余一切交给调度中心来调度，从而实现解耦。</p><h3 id="18-Vue组件之间的通信"><a href="#18-Vue组件之间的通信" class="headerlink" title="18.Vue组件之间的通信"></a>18.Vue组件之间的通信</h3><ul><li>父传子: props、attr、ref调用函数</li><li>子传父: $emit、listeners</li><li>兄弟组件通信: vuex、eventBus</li></ul><h3 id="19-Vue双向绑定的原理"><a href="#19-Vue双向绑定的原理" class="headerlink" title="19.Vue双向绑定的原理"></a>19.Vue双向绑定的原理</h3><p>Vue是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发响应的监听回调。</p><p>具体步骤：</p><p>第一步：需要 Observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到数据变化。</p><p>第二步：Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>第三步：Watcher 订阅者是 Observe 和 Compile 之间通信的桥梁，主要的事情是：</p><p>1、在自身实例化时往属性订阅器(dep)里面添加自己</p><p>2、自身必须有一个update()</p><p>3、待属性变动dep.notify()通知时，调用自身的 update() 方法，并触发 Compile 中绑定回调，则功成身退。</p><p>总结：MVVM作为数据绑定的入口，整合 Observe、Compile 和 Watcher 三者，通过 Observe 来监听自己的 Model 数据变化。 通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observe 和 Compile 之间的通信桥梁； 达到数据变化 -&gt; 视图更新; 视图交互(input) -&gt; 数据 Model 变更的双向绑定效果。</p><h3 id="20-Vue-Computed的实现原理和缓存原理"><a href="#20-Vue-Computed的实现原理和缓存原理" class="headerlink" title="20.Vue Computed的实现原理和缓存原理"></a>20.Vue Computed的实现原理和缓存原理</h3><p>实现原理：遍历computed对象的key，调用<strong>defineComputed</strong>函数，给对应的key添加getter和setter。同时给每个对象添加一个watcher，通过这个watch来进行派发通知，更新视图</p><p>缓存原理：缓存就是在获取 getter 数据的，判断是否值相等，相等的话就直接返回，不再进行更新视图</p><h3 id="21-Vue-watch-和-computed的区别"><a href="#21-Vue-watch-和-computed的区别" class="headerlink" title="21.Vue watch 和 computed的区别"></a>21.Vue watch 和 computed的区别</h3><p>watch 主要监控数据的变化，根据变化自定义执行相应的操作 computed 在计算获得数据，在getter之后会进行缓存，只有依赖的属性值变化后，才会发生变化，否则从缓存获取数据</p><h3 id="22-MVVM框架是什么？它和其它框架（Jquery）的区别是什么？哪些场景适合？"><a href="#22-MVVM框架是什么？它和其它框架（Jquery）的区别是什么？哪些场景适合？" class="headerlink" title="22.MVVM框架是什么？它和其它框架（Jquery）的区别是什么？哪些场景适合？"></a>22.MVVM框架是什么？它和其它框架（Jquery）的区别是什么？哪些场景适合？</h3><p>MVVM分为Model、View、ViewModel三者</p><ul><li><strong>Model</strong> 代表数据模型，数据和业务逻辑都在Model层中定义</li><li><strong>View</strong> 代表UI视图，负责数据展示</li><li><strong>ViewModel</strong> 负责监听 <strong>Model</strong> 中数据的改变并且控制视图更新，处理用户交互操作：</li></ul><p><strong>Model</strong> 和 <strong>View</strong> 并无直接关联，而是通过 <strong>ViewModel</strong> 来进行联系的， <strong>Model</strong> 和 <strong>ViewModel</strong>之间有着双向数据绑定的联系。因此当 <strong>Model</strong> 中的数据改变时会触发 <strong>View</strong> 层的刷新，<strong>View</strong> 中由于用户交互操作而改变的数据也会在 <strong>Model</strong> 中同步</p><p>区别：这种模式实现了 Model 和 View的数据自动同步，因此开发时这需要要专注对数据的维护操作即可，而不需要自己操作dom 场景：数据操作比较多的场景，更加便捷</p><p>面试回答: jQuery主要简化了DOM的操作，是一个JS函数库。Vue，主要实现了MVVM的模式框架，通过数据驱动视图的变化，不需要自己操作DOM，增加了开发效率，并实现了组件化的思想，增加项目的可维护性。</p><h3 id="23-Vue-mixin-的原理"><a href="#23-Vue-mixin-的原理" class="headerlink" title="23.Vue mixin 的原理"></a>23.Vue mixin 的原理</h3><p>主要思路合并对象，遍历循环mixin对象，然后找到对应的钩子函数进行合并。</p><h3 id="24-nextTick-实现原理"><a href="#24-nextTick-实现原理" class="headerlink" title="24.nextTick 实现原理"></a>24.nextTick 实现原理</h3><p>概念补充: JS，是单线程的，利用JS的事件循环</p><p>事件循环大致分为以下几个步骤:</p><p>(1) 所有同步任务都在主线程上执行，形成一个执行栈(execution context stack)</p><p>(2) 主线程之外，还存在一个”任务队列”(task queue)。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p><p>(3) 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p><p>(4) 主线程不断重复上面的第三步</p><h3 id="25-宏任务-macro-task-和-微任务-micro-task"><a href="#25-宏任务-macro-task-和-微任务-micro-task" class="headerlink" title="25.宏任务(macro task) 和 微任务(micro task)"></a>25.宏任务(macro task) 和 微任务(micro task)</h3><p>先执行宏观任务，再执行微观任务(是对异步 处理的 优先级)</p><ul><li>宏观任务：setTimeout、MessageChannel、postMessage、setImmediate…</li><li>微观任务：MutationObsever、Promise.then</li></ul><p>```javascript for (macroTask of macroTaskQueue) { // 1. Handle current MACRO-TASK handleMacroTask();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2. Handle all MICRO-TASK</span><br><span class="line"> for (microTask of microTaskQueue) &#123;</span><br><span class="line">     handleMicroTask(microTask);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>}</p><p>nextTick原理：</p><ul><li><p>会有一个callbacks数组，接受nextTick的回调函数,push进去</p></li><li><p>首先判断是否支持Promise，支持则利用的Promise.then进行调用遍历调用callbacks数组</p></li><li><p>判断是否支持 MutationObserver，支持则利用 MutationObserver 遍历调用callbacks数组</p></li><li><p>判断是否支持 setImmediate，支持则利用 setImmediate 遍历调用callbacks数组</p></li><li><p>都不支持，则利用setTimeout进行遍历调用 callbacks数组</p></li></ul><p>面试回答: 把传入的回调函数压入 一个 callbacks 数组，判断当前浏览器支持宏任务还是微任务函数，在对应的函数里面进行回调 遍历callbacks 数组，然后执行相应的函数。</p><h3 id="26-什么是虚拟-dom-？"><a href="#26-什么是虚拟-dom-？" class="headerlink" title="26.什么是虚拟 dom ？"></a>26.什么是虚拟 dom ？</h3><p>VNode是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展VNode的灵活性以及实现一些特殊 feature的。</p><p>Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode的 create、diff、 patch等过程。</p><h3 id="27-说一下Vuex"><a href="#27-说一下Vuex" class="headerlink" title="27.说一下Vuex"></a>27.说一下Vuex</h3><p><strong>vuex有哪几种属性</strong>？</p><p>vuex具有五种属性: state、getter、mutation、action、module</p><p><strong>vuex的state特性是？</strong></p><ul><li><p>vuex就是一个仓库，仓库里面放很多对象。state就是数据存放地，对应于一般vue对象里面的data</p></li><li><p>state里面存放的数据是响应式的</p></li></ul><p><strong>vuex的getter特性是？</strong></p><ul><li><p>getters可以对state进行计算操作</p></li><li><p>可以在多组件之间复用</p></li></ul><p><strong>vuex的mutation特性是？</strong></p><ul><li><p>action类似于mutation</p></li><li><p>action提价的是mutation，而是不是直接变更状态</p></li><li><p>action可以包含任何异步操作</p></li></ul><p><strong>不用vuex会带来什么问题？</strong></p><ul><li><p>可维护性会下降，你要想修改数据，你得维护三个地方</p></li><li><p>可读性下降，因为一个组件里的数据，你根本看不出来是从哪来的</p></li><li><p>增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。</p></li></ul><h3 id="28-请详细说下你对vue生命周期的理解？"><a href="#28-请详细说下你对vue生命周期的理解？" class="headerlink" title="28.请详细说下你对vue生命周期的理解？"></a>28.请详细说下你对vue生命周期的理解？</h3><p>总共分为8个阶段<strong>创建前/后,载入前/后,更新前/后,销毁前/后</strong></p><p>创建前/后: 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。</p><p>载入前/后: 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p><p>更新前/后: 当data变化时，会触发beforeUpdate和updated方法。</p><p>销毁前/后: 在执行destroy方法后，对data的改变不会触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p><h3 id="29-请说下封装-vue-组件的过程？"><a href="#29-请说下封装-vue-组件的过程？" class="headerlink" title="29.请说下封装 vue 组件的过程？"></a>29.请说下封装 vue 组件的过程？</h3><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模快，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p><p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据递给父组件。可以采用emit方法。</p><h3 id="30-说一下keep-live组件的原理"><a href="#30-说一下keep-live组件的原理" class="headerlink" title="30.说一下keep-live组件的原理"></a>30.说一下keep-live组件的原理</h3><p><strong>keep-alive是什么</strong></p><p>keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。</p><p><strong>keep-alive运行原理</strong></p><ul><li><p>获取keep-alive包裹的第一个子组件对象以其组件名</p></li><li><p>根据设定的黑白名单(如果有)进行条件匹配，决定是否缓存。不匹配，直接返回组件实例(VNode)</p></li><li><p>根据组件ID和tag生成缓存Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该 key 在 this.keys 中的位置（更新key的位置是实现LRU置换策略的关键），否则执行第四步</p></li><li><p>在 this.cache 对象中存储该组件实例并保存 key 值，之后检查缓存的实例数量是否超过 max 的设置值，超过则根据LRU置换策略删除最近最久未使用的实例（即是下标为0的那个key）。</p></li><li><p>最后并且很重要，将该组件实例的 keepAlive 属性值设置为 true </p></li></ul><p>面试回答: 根据设定的黑白名单(如果有)进行条件匹配，决定是否缓存。不匹配，直接返回组件实例(VNode)，如果匹配的话，存储到一个对象里面，并根据组件ID和生成缓存key，并且标识该组件已缓存。然后如果下次再匹配的话，就会通过对应的缓存Key从内存里面获取对应的Vue实例。</p><h3 id="31-Proxy-和-Object-defineProperty-的优劣？"><a href="#31-Proxy-和-Object-defineProperty-的优劣？" class="headerlink" title="31.Proxy 和 Object.defineProperty 的优劣？"></a>31.Proxy 和 Object.defineProperty 的优劣？</h3><ul><li><p>Proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是</p></li><li><p>*Object.defineProperty()**不具备的</p></li><li><p>Proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而 <strong>Object.defineProperty</strong> 只能遍历对象属性直接修改</p></li><li><p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p></li><li><p>当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。</p></li></ul><h3 id="32-聊一聊常见的浏览器端数据存储方案"><a href="#32-聊一聊常见的浏览器端数据存储方案" class="headerlink" title="32.聊一聊常见的浏览器端数据存储方案"></a>32.聊一聊常见的浏览器端数据存储方案</h3><p>数据存储方案：</p><ul><li>Cookie</li><li>Web存储(localStorage和sessionStorage)</li><li>IndexedDB</li></ul><p>大概说一下Cookie和localStorage、sessionStorage的功能特性。问到的话，Cookie的缺点就是，存储量少、数据大影响性能、只能储存字符串、安全性问题、需要检查Cookie能否使用</p><h3 id="33-Flexible布局方案的原理"><a href="#33-Flexible布局方案的原理" class="headerlink" title="33.Flexible布局方案的原理"></a>33.Flexible布局方案的原理</h3><ul><li>获取document的适口宽度 除以 10</li><li>得出 1rem = viewWidth / 10</li><li>然后设置 html的font-size为 rem + ‘px’</li></ul><h3 id="34-为什么会有深拷贝和浅拷贝？日常开发中如何使用？，如何实现一个深拷贝？"><a href="#34-为什么会有深拷贝和浅拷贝？日常开发中如何使用？，如何实现一个深拷贝？" class="headerlink" title="34.为什么会有深拷贝和浅拷贝？日常开发中如何使用？，如何实现一个深拷贝？"></a>34.为什么会有深拷贝和浅拷贝？日常开发中如何使用？，如何实现一个深拷贝？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>深拷贝，支持常见类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Any&#125;</span> <span class="variable">values</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Any&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the 3 simple types, and null or undefined</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == values || <span class="string">&quot;object&quot;</span> != <span class="keyword">typeof</span> values) <span class="keyword">return</span> values;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Date</span></span><br><span class="line">    <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        copy = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        copy.setTime(values.getTime());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Array</span></span><br><span class="line">    <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        copy = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">            copy[i] = deepClone(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object</span></span><br><span class="line">    <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        copy = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> values) &#123;</span><br><span class="line">            <span class="keyword">if</span> (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Unable to copy values! Its type isn&#x27;t supported.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是一个数组，就声明一个数据组，然后循环遍历，递归赋值。 如果是一个对象，就声明一个对象，然后判断是否子元素,递归赋值</p><p>除了递归，我们还可以借用JSON对象的parse和stringify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let _obj &#x3D; JSON.stringify(obj),</span><br><span class="line">    objClone &#x3D; JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-后台管理系统权限路由实现"><a href="#35-后台管理系统权限路由实现" class="headerlink" title="35.后台管理系统权限路由实现?"></a>35.后台管理系统权限路由实现?</h3><p>权限控制的主体思路，前端会有一份路由表，它表示了每个路由的访问权限。当用户登录之后，通过<strong>token</strong>获取用户的<strong>role</strong>，动态根据用户的<strong>role</strong>算出其对应有的权限的路由，通过<strong>router.addRoutes</strong>动态挂载路由。</p><h3 id="36-vue-组件-data-为什么必须是函数？"><a href="#36-vue-组件-data-为什么必须是函数？" class="headerlink" title="36.vue 组件 data 为什么必须是函数？"></a>36.vue 组件 data 为什么必须是函数？</h3><p>如果是对象的话，每一个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变。 而data是函数的话，每个vue组件的data都因为函数有了自己的作用域，互不干扰。</p><h3 id="37-webpack-是什么？为什么使用webpack-WebPack和Grunt以及Gulp相比有什么特性"><a href="#37-webpack-是什么？为什么使用webpack-WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="37.webpack 是什么？为什么使用webpack? WebPack和Grunt以及Gulp相比有什么特性"></a>37.webpack 是什么？为什么使用webpack? WebPack和Grunt以及Gulp相比有什么特性</h3><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p><p>因为通过webpack把一些繁琐的操作的，比如CSS添加对应的前缀，通过引入模快的方式来进行操作。</p><h3 id="38-现在开发如何解决浏览器兼容问题？"><a href="#38-现在开发如何解决浏览器兼容问题？" class="headerlink" title="38.现在开发如何解决浏览器兼容问题？"></a>38.现在开发如何解决浏览器兼容问题？</h3><ul><li><strong>样式兼容性（css）方面</strong>,通过 Normalize.css 抹平差异</li><li>利用webpack或者其它工具，给CSS添加浏览器前缀</li><li>交互兼容性（javascript，exp: 事件兼容的问题、new Date()构造函数使用、获取 scrollTop 通过 document.documentElement.scrollTop 兼容非chrome浏览器 <a href="https://link.zhihu.com/?target=https://juejin.im/post/5b3da006e51d4518f140edb2">相关链接</a></li></ul><h3 id="39-前端如何指定浏览器使用最新内核"><a href="#39-前端如何指定浏览器使用最新内核" class="headerlink" title="39.前端如何指定浏览器使用最新内核?"></a>39.前端如何指定浏览器使用最新内核?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;renderer&quot; content&#x3D;&quot;webkit&quot;&#x2F;&gt; &#x2F;&#x2F; 强制Chromium内核，作用于360浏览器、QQ浏览器等国产双核浏览器</span><br><span class="line">&lt;meta name&#x3D;&quot;force-rendering&quot; content&#x3D;&quot;webkit&quot;&#x2F;&gt; &#x2F;&#x2F; 强制Chromium内核，作用于其他双核浏览器</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge,chrome&#x3D;1&quot;&#x2F;&gt; &#x2F;&#x2F; 如果有安装 Google Chrome Frame 插件则强制为Chromium内核，否则强制本机支持的最高版本IE内核，作用于IE浏览器</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>综合面试题（1）</title>
      <link href="/2020/09031.html"/>
      <url>/2020/09031.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、http和https的区别："><a href="#一、http和https的区别：" class="headerlink" title="一、http和https的区别："></a><strong>一、http和https的区别：</strong></h3><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ==SSL 加密传输协议==。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是==80==，后者是==443==。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><h3 id="二、什么是闭包，为什么要用它？"><a href="#二、什么是闭包，为什么要用它？" class="headerlink" title="二、什么是闭包，为什么要用它？"></a>二、什么是闭包，为什么要用它？</h3><p><strong>闭包是指有权访问另一个函数作用域内变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。 </p><p><strong>闭包的两个常用的用途：什么时候用闭包？</strong></p><p>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p><p>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">function a()&#123;</span><br><span class="line">    var n &#x3D; 0;</span><br><span class="line">    function add()&#123;</span><br><span class="line">       n++;</span><br><span class="line">       console.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return add;</span><br><span class="line">&#125;</span><br><span class="line">var a1 &#x3D; a(); &#x2F;&#x2F;注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class="line">a1();    &#x2F;&#x2F;1</span><br><span class="line">a1();    &#x2F;&#x2F;2  第二次调用n变量还在内存中</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="三、什么是-DOM-和-BOM？"><a href="#三、什么是-DOM-和-BOM？" class="headerlink" title="三、什么是 DOM 和 BOM？"></a>三、什么是 DOM 和 BOM？</h3><p><strong>DOM</strong> 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。 </p><p><strong>BOM</strong>  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局） 对象。==DOM 的最根本的对象 document 对象也是 BOM 的 window 对 象的子对象==。 </p><h3 id="四、事件委托是什么？"><a href="#四、事件委托是什么？" class="headerlink" title="四、事件委托是什么？"></a>四、事件委托是什么？</h3><p><strong>事件委托</strong> 本质上是利用了浏览器事件冒泡的机制。 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗 。</p><h3 id="五、什么是事件传播"><a href="#五、什么是事件传播" class="headerlink" title="五、什么是事件传播?"></a>五、什么是事件传播?</h3><p>当<strong>事件</strong>发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。 </p><p>事件传播有三个阶段：</p><p>捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</p><p>window—-&gt; document—-&gt; html—-&gt; body —-&gt;目标元素 </p><p>目标阶段–事件已达到目标元素。</p><p>冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</p><p>当前元素—-&gt;body —-&gt; html—-&gt;document —-&gt;window </p><h3 id="六、DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#六、DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="六、DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>六、DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment()    &#x2F;&#x2F;创建一个DOM片段 </span><br><span class="line"></span><br><span class="line">createElement()   &#x2F;&#x2F;创建一个具体的元素</span><br><span class="line"></span><br><span class="line"> createTextNode()   &#x2F;&#x2F;创建一个文本节点</span><br></pre></td></tr></table></figure><p>（2）添加、移除、替换、插入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendChild(node) 添加</span><br><span class="line"></span><br><span class="line"> removeChild(node) 移除 </span><br><span class="line"></span><br><span class="line"> replaceChild(new,old) 替换 </span><br><span class="line"></span><br><span class="line"> insertBefore(new,old) 插入 </span><br></pre></td></tr></table></figure><p>（3）查找 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getElementById(); </span><br><span class="line"></span><br><span class="line"> getElementsByName(); </span><br><span class="line"></span><br><span class="line"> getElementsByTagName(); </span><br><span class="line"></span><br><span class="line"> getElementsByClassName(); </span><br><span class="line"></span><br><span class="line"> querySelector(); </span><br><span class="line"></span><br><span class="line"> querySelectorAll(); </span><br></pre></td></tr></table></figure><p>（4）属性操作 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getAttribute(key);</span><br><span class="line"></span><br><span class="line">setAttribute(key, value);</span><br><span class="line"></span><br><span class="line">hasAttribute(key);</span><br><span class="line"></span><br><span class="line">removeAttribute(key);</span><br></pre></td></tr></table></figure><h3 id="七、浏览器兼容性问题，解决方法"><a href="#七、浏览器兼容性问题，解决方法" class="headerlink" title="七、浏览器兼容性问题，解决方法"></a>七、浏览器兼容性问题，解决方法</h3><p>浏览器兼容问题一：不同浏览器的标签默认的margin和padding不同:<br> 解决方案：CSS里    *{margin:0;padding:0;}</p><p> 浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin会比设置的大；<br> 解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性；</p><p> 浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度；<br> 解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p><p> 浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6里的间距会超过设置的间距；<br> 解决方案：在display:block;后面加入display:inline;display:table;</p><p> 浏览器兼容问题五：图片默认有间距，几个img标签放在一起的时候，有些浏览器会有默认的间距；<br> 解决方案：使用float属性为img布局或者设置display:block；</p><p> 浏览器兼容问题六：标签最低高度设置min-height不兼容；<br> 解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;} </p><p> 浏览器兼容问题七：透明度的兼容CSS设置；<br> 解决方案：.transparent_class {<br>        filter:alpha(opacity=50);<br>       -moz-opacity:0.5;<br>        -khtml-opacity: 0.5;<br>       opacity: 0.5;<br> }<br> JS兼容问题：<br> 1、通过class获取标签： 原生js方法“document.getElementsByClassName”在ie8及其以下浏览器中，不能使用。<br> 解决方案：function getElesByClassName(className){<br>          if(document.getElementsByClassName(className)){ //如果浏览器支持                document.getElementsByClassName()方法<br>              return document.getElementsByClassName(className);<br>          }else{<br>              var all=document.getElementsByTagName(“*”);  // 获取所有元素<br>              var arr=[];<br>              for(var i=0;i&lt;all.length;i++){<br>                  if(all[i].className==className){<br>                      arr.push(all[i]);<br>                   }<br>               }<br>               return arr;<br>           }<br>      }<br> 2、事件绑定 ：addEventListener只有IE9以上版本的IE浏览器上能够兼容，IE8或者更低的版本是不支持<br> 解决方案：function addEvent(obj,event,fn){<br> //现代：addEventLister 不用加on<br> //ie：touchEvent 需要加on<br> if (window.addEventListener){<br> obj.addEventListener(event,fn);<br> }else{<br> obj.attachEvent(“on”+event, fn);<br> }<br> }<br> 3、ajax  ：不是所有浏览器都支持XMLHttpRequest对象的，在IE6及以下版本都需要创建一个ActiveXObject(“Microsoft.XMLHTTP”)<br> 解决方案：if (window.XMLHttpRequest){<br>   var ajax=new XMLHttpRequest();<br>      }else{<br> var ajax=new ActiveXObject(“Msxml2.XMLHTTP”);<br> }<br> 4、获取样式： ie不支持getComputedStyle方法，IE下获取元素的实际属性值使用currentStyle属性<br> 解决方案：function getStyle(el,styleName){<br> if (el.currentStyle){<br> return el.currentStyle[styleName];<br> }else{<br> return getComputedStyle(el, null)[styleName];<br> }<br> }</p><p>不同的浏览器对CSS的解析结果是不同的，因此会导致相同的CSS输出的页面效果不同，这就需要CSS Hack来解决浏览器局部的兼容性问题。而这个针对不同的浏览器写不同的CSS 代码的过程，就叫CSS Hack。 </p><p>CSS Hack常见的有三种形式：CSS属性Hack、CSS选择符Hack以及IE条件注释Hack， Hack主要针对IE浏览器。</p><p>1、属性级Hack：比如IE6能识别下划线”_”和星号” * “，IE7能识别星号” * “，但不能识别下划线”_”，而firefox两个都不能认识。 </p><p>2、选择符级Hack：比如IE6能识别<em>html .class{}，IE7能识别</em>+html .class{}或者*:first-child+html .class{}。</p><p>3、IE条件注释Hack：IE条件注释是微软从IE5开始就提供的一种非标准逻辑语句。比如针对所有IE：&lt;!–[if IE]&gt;&lt;!–您的代码–&gt;&lt;![endif]–&gt;，针对IE6及以下版本：&lt;!–[if lt IE 7]&gt;&lt;!–您的代码–&gt;&lt;![endif]–&gt;，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都 会生效。</p><p>PS：条件注释只有在IE浏览器下才能执行，这个代码在非IE浏览下被当做注释视而不见。可以通过IE条件注释载入不同的CSS、JS、HTML和服务器代码等。</p><p>1.<strong>IE9一下浏览器不能使用opacity</strong> </p><p>解决方法：opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); </p><p>2.<strong>cursor:hand 显示手型在safari 上不支持</strong> </p><p>解决方案：统一使用 cursor:pointer </p><p>3.解决 <code>IE6</code> 不支持 <code>min-height</code> 属性的问题</p><p>解决方法：min-height: 350px;_height: 350px;</p><p>4.让 <code>IE7 IE8</code> 支持 <code>CSS3 background-size</code>属性</p><p>由于 background-size 是 CSS3 新增的属性，所以 IE 低版本自然就不支持了，但是老外写了一个 htc 文件，名叫 <a href="https://link.juejin.im/?target=%E6%A0%87%E7%AD%BE">background-size polyfill</a>，使用该文件能够让 IE7、IE8 支持 background-size 属性。其原理是创建一个 img 元素插入到容器中，并重新计算宽度、高度、left、top 等值，模拟 background-size 的效果。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  background-image: url(&#39;img&#x2F;37.png&#39;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  -ms-behavior: url(&#39;css&#x2F;backgroundsize.min.htc&#39;);</span><br><span class="line">  behavior: url(&#39;css&#x2F;backgroundsize.min.htc&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、数组和字符串"><a href="#八、数组和字符串" class="headerlink" title="八、数组和字符串"></a>八、数组和字符串</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageslim" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageslim" alt="img"> </p><h3 id="九-常用的正则表达式"><a href="#九-常用的正则表达式" class="headerlink" title="九.常用的正则表达式"></a>九.常用的正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;（1）匹配 16 进制颜色值</span><br><span class="line">var color &#x3D; &#x2F;#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;（2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="line">var date &#x3D; &#x2F;^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$&#x2F;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;（3）匹配 qq 号</span><br><span class="line">var qq &#x3D; &#x2F;^[1-9][0-9]&#123;4,10&#125;$&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;（4）手机号码正则</span><br><span class="line">var phone &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;（5）用户名正则</span><br><span class="line">var username &#x3D; &#x2F;^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$&#x2F;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;（6）Email正则</span><br><span class="line">var email &#x3D; &#x2F;^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$&#x2F;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;（7）身份证号（18位）正则</span><br><span class="line">var cP &#x3D; &#x2F;^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$&#x2F;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;（8）URL正则</span><br><span class="line">var urlP&#x3D; &#x2F;^((https?|ftp|file):\&#x2F;\&#x2F;)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\&#x2F;\w \.-]*)*\&#x2F;?$&#x2F;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; (9)ipv4地址正则</span><br><span class="line">var ipP &#x3D; &#x2F;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&#x2F;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; (10)&#x2F;&#x2F;车牌号正则</span><br><span class="line">var cPattern &#x3D; &#x2F;^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$&#x2F;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; (11)强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：var pwd &#x3D; &#x2F;^(?&#x3D;.\d)(?&#x3D;.[a-z])(?&#x3D;.[A-Z]).&#123;8,10&#125;$&#x2F;</span><br></pre></td></tr></table></figure><h3 id="十、优化手段"><a href="#十、优化手段" class="headerlink" title="十、优化手段"></a>十、优化手段</h3><p><img src="C:\Users\32610\Desktop\优化.png"></p><p>1.==三个方面就前端性能进行总结：网络方面、DOM操作及渲染方面、数据方面==。 </p><p><strong>网络方面：</strong></p><p>1.减少http请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">合并js文件</span><br><span class="line"></span><br><span class="line">合并css文件</span><br><span class="line"></span><br><span class="line">雪碧图的使用(css sprite)</span><br><span class="line"></span><br><span class="line">使用base64表示简单的图片</span><br></pre></td></tr></table></figure><p>2.<strong>减小资源体积</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip压缩</span><br><span class="line"></span><br><span class="line">js混淆</span><br><span class="line"></span><br><span class="line">css压缩</span><br><span class="line"></span><br><span class="line">图片压缩</span><br></pre></td></tr></table></figure><p>3.<strong>缓存</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DNS缓存</span><br><span class="line"></span><br><span class="line">CDN部署与缓存</span><br><span class="line"></span><br><span class="line">http缓存</span><br></pre></td></tr></table></figure><p>4.<strong>移动端优化</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用长cache，减少重定向</span><br><span class="line"></span><br><span class="line">首屏优化，保证首屏加载数据小于14kb</span><br><span class="line"></span><br><span class="line">不滥用web字体</span><br><span class="line"></span><br><span class="line">长列表滚动优化</span><br><span class="line"></span><br><span class="line">函数防抖和函数节流</span><br><span class="line"></span><br><span class="line">使用touchstart、touchend代替click</span><br><span class="line"></span><br><span class="line">HTML的viewport设置</span><br><span class="line"></span><br><span class="line">开启GPU渲染加速</span><br></pre></td></tr></table></figure><h3 id="十一（1）cookie、session、token"><a href="#十一（1）cookie、session、token" class="headerlink" title="十一（1）cookie、session、token"></a>十一（1）cookie、session、token</h3><p>（1）==cookie==由==服务器生成，发送给浏览器==,浏览器把cookiel以kv形 式保存到某个目录下的文本文件内，下一 -次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端 上的，所以浏览器加入了- -些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p><p><strong>cookie的缺点</strong></p><p>​    （1）==Cookie`数量和长度的限制== ，每个 Web 站点能设置的 Cookie 总数不能超过 20个。每个cookie长度不能超过4KB 。</p><p>​     （2）==用户配置为禁用==。有些用户禁用了浏览器或客户端设备接收 Cookie 的能力，因此限制了这一功能。</p><p>​    （3）由于在HTTP请求中的cookie是==明文传递的，潜在的安全风险，==Cookie 可能会被篡改</p><p>​    （4）==有些状态不可能保存在客户端==</p><p>​    （5）cookie会被附加在每个HTTP请求中，所以无形中==增加了流量==</p><p>​    （6）==cookie一般不可跨域使用==</p><p>​    （7）没有封装好的setCookie和getCookie方法，需要开发者自省封装</p><p>（2）==session==是为区分用户id,服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个”身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个”身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用cookie的方式。</p><p>==服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁==。这种用户信息存储方式相对cookie来说更安全，可是session有一 个缺陷: 如果web服务器做了负载均衡，那么下一-个操作请求到了另-台服务器的时候session会丢失。</p><p>（3）基于==Token==的身份验证的过程如下:<br>1.用户通过用户名和密码发送请求。<br>2.程序验证。<br>3.程序返回一个签名的token 给客户端。<br>4.客户端储存token,并且每次用于每次发送请求。<br>5.服务端验证token并返回数据。</p><p>以以几点==特性==会让你在程序中使用基于Token的身份验证<br>1.无状态、可扩展<br>2.支持移动设备<br>3.跨程序调用</p><p>4.安全</p><h3 id="十一（2）sessionStorage、localStorage和cookie的区别"><a href="#十一（2）sessionStorage、localStorage和cookie的区别" class="headerlink" title="十一（2）sessionStorage、localStorage和cookie的区别"></a>十一（2）<strong>sessionStorage、localStorage和cookie的区别</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">简洁答案：</span><br><span class="line"></span><br><span class="line">相同点：都存储在客户端</span><br><span class="line"></span><br><span class="line">不同点：1.存储大小</span><br><span class="line"></span><br><span class="line">· cookie数据大小不能超过4k。</span><br><span class="line"></span><br><span class="line">· sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</span><br><span class="line"></span><br><span class="line">2.有效时间</span><br><span class="line"></span><br><span class="line">· localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</span><br><span class="line"></span><br><span class="line">· sessionStorage  数据在当前浏览器窗口关闭后自动删除。</span><br><span class="line"></span><br><span class="line">· cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</span><br><span class="line"></span><br><span class="line">1. 数据与服务器之间的交互方式</span><br><span class="line"></span><br><span class="line">· cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</span><br><span class="line"></span><br><span class="line">· sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</span><br></pre></td></tr></table></figure><p>1）相同点是都是==保存在浏览器端、且同源的== </p><p>2）cookie数据始终在同源的http请求中携带（即使不需要），即==cookie在浏览器和服务器间来回传递==，而==sessionStorage和localStorage==不会自动把数据发送给服务器，==仅在本地保存==。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </p><p>3）存储大小限制也不同，==cookie==数据不能超过==4K==，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。==sessionStorage和localStorage==虽然也有存储大小的限制，但比cookie大得多，可以达到==5M==或更大 </p><p>4）数据有效期不同，==sessionStorage==：仅在当前浏览器窗口==关闭之前有效==；==localStorage==：==始终有效==，窗口或浏览器关闭也一直保存，因此用作持久数据；==cookie==：==只在设置的cookie过期时间之前有效==，即使窗口关闭或浏览器关闭</p><p> 5）作用域不同，==sessionStorage不在不同的浏览器窗口中共享==，即使是同一个页面；==localstorage==在所有同源窗口中都是共享的；==cookie==也是在所有同源窗口中都是共享的</p><p> 6）web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 7）web Storage的api接口使用更方便 </p><h3 id="十二、xss域CSRF的区别"><a href="#十二、xss域CSRF的区别" class="headerlink" title="十二、xss域CSRF的区别"></a>十二、xss域CSRF的区别</h3><p>1.XSS 是代码注入问题，CSRF 是 HTTP 问题 </p><p>2.XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。 </p><p>3.xss: 跨站脚本攻击 ，攻击者通过注入非法的 html 标签或者 javascript 代码，从而当用户浏览该网页时，控制用户浏览器 </p><p>4.跨站点请求伪造 ,充用户发起请求（在用户不知情的情况下） </p><h3 id="十三、XML和JSON的区别"><a href="#十三、XML和JSON的区别" class="headerlink" title="十三、XML和JSON的区别"></a>十三、XML和JSON的区别</h3><p>1.XML：扩展标记语言 </p><p>2.JSON一种轻量级的数据交换格式 </p><p>它们都是一种数据交换格式。</p><p>1，xml是重量级的，json是轻量级的。</p><p>2，xml在传输过程中比较占带宽，json占带宽少，易于压缩。</p><p>3，xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。</p><p>4，json可用jackson，gson等方法解析，xml可用dom，sax，demo4j等方式解析。</p><h3 id="十四、src和href的区别"><a href="#十四、src和href的区别" class="headerlink" title="十四、src和href的区别"></a>十四、src和href的区别</h3><p>1.href是超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a。 </p><p>2.浏览器会识别href引用的文档并行下载该文档，并且不会停止对当前文档的处理 。</p><p>3.src是引入，src的内容是页面必不可少的一部分。src指向的内容会嵌入到文档中当前标签所在的位置。常用的有：img、script、iframe。 “</p><p>4.当浏览器解析到src引用时，会暂停浏览器的渲染，直到该资源加载完毕。这也是将js 脚本放在底部而不是头部的原因 </p><h3 id="十五、用纯CSS创建一个三角形"><a href="#十五、用纯CSS创建一个三角形" class="headerlink" title="十五、用纯CSS创建一个三角形"></a>十五、用纯CSS创建一个三角形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line"></span><br><span class="line">         width: 0;</span><br><span class="line">         height: 0;</span><br><span class="line">         border-top: 10px solid transparent;</span><br><span class="line">         border-bottom: 10px solid #000;</span><br><span class="line">         border-left: 10px solid transparent;</span><br><span class="line">         border-right: 10px solid transparent;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="十六、-this-和-this-关键字有何不同？"><a href="#十六、-this-和-this-关键字有何不同？" class="headerlink" title="十六、$(this) 和 this 关键字有何不同？"></a>十六、$(this) 和 this 关键字有何不同？</h3><p>$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。</p><p>而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。</p><h3 id="十七、盒子上下左右居中，几种方法"><a href="#十七、盒子上下左右居中，几种方法" class="headerlink" title="十七、盒子上下左右居中，几种方法"></a>十七、盒子上下左右居中，几种方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一：已知元素的高宽</span><br><span class="line"></span><br><span class="line">\#div1&#123;</span><br><span class="line">    background-color:#6699FF;</span><br><span class="line">    width:200px</span><br><span class="line">    height:200px;</span><br><span class="line">    position: absolute; &#x2F;&#x2F;父元素需要相对定位</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top:-100px ; &#x2F;&#x2F;二分之一的 height，width</span><br><span class="line">    margin-left: -100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法二:未知父元素高宽</span><br><span class="line"></span><br><span class="line">\#div1&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: #6699FF;</span><br><span class="line">    margin:auto;</span><br><span class="line">    position: absolute; &#x2F;&#x2F;父元素需要相对定位</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flex使盒子居中</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父盒子</span><br><span class="line"></span><br><span class="line">    .da&#123;</span><br><span class="line">       width: 500px;</span><br><span class="line">       height: 500px;</span><br><span class="line">       background: green;</span><br><span class="line">       display: flex; &#x2F;&#x2F; 使用flex</span><br><span class="line">       align-items: center; &#x2F;&#x2F; 上下居中</span><br><span class="line">       justify-content: center; &#x2F;&#x2F; 左右居中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">css3中的新属性transform实现盒子居中</span><br><span class="line"></span><br><span class="line">    .da&#123;</span><br><span class="line">        &#x2F;*父盒子*&#x2F;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        background: green;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      #er&#123;</span><br><span class="line">        &#x2F;*我是子盒子我要居中*&#x2F;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background: red;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">利用css3的新增属性table-cell, vertical-align:middle;</span><br><span class="line"></span><br><span class="line">    .da&#123;</span><br><span class="line">        &#x2F;*父盒子*&#x2F;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        background: green;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        vertical-align: middle; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      #er&#123;</span><br><span class="line">        &#x2F;*我是子盒子我要居中*&#x2F;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background: red;</span><br><span class="line">        margin: auto;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="十八、深浅拷贝问题"><a href="#十八、深浅拷贝问题" class="headerlink" title="十八、深浅拷贝问题"></a>十八、深浅拷贝问题</h3><p>1.值类型和引用类型</p><p>值类型（基本类型）：存在栈中</p><p>引用类型:存在堆中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本类型 </span><br><span class="line"></span><br><span class="line">var a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var b &#x3D; a; </span><br><span class="line"></span><br><span class="line">a &#x3D; 2; </span><br><span class="line"></span><br><span class="line">console.log(a, b);         &#x2F;&#x2F; 2, 1 ,a b指向</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引用类型指向同一份数据 </span><br><span class="line"></span><br><span class="line">var a &#x3D; &#123;c: 1&#125;; </span><br><span class="line"></span><br><span class="line">var b &#x3D; a; </span><br><span class="line"></span><br><span class="line">a.c &#x3D; 2; </span><br><span class="line"></span><br><span class="line">console.log(a.c, b.c); &#x2F;&#x2F; 2, 2 全是2,a b指向同一份数据</span><br></pre></td></tr></table></figure><h3 id="十九、延迟加载的问题"><a href="#十九、延迟加载的问题" class="headerlink" title="十九、延迟加载的问题"></a>十九、延迟加载的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defer属性</span><br><span class="line">async 属性</span><br><span class="line">动态创建DOM方式</span><br><span class="line">使用jq的getScript方法</span><br><span class="line">使用setTimeout延时方法</span><br><span class="line">让js最后加载</span><br></pre></td></tr></table></figure><h3 id="二十、从输入URL到页面加载发生了什么？"><a href="#二十、从输入URL到页面加载发生了什么？" class="headerlink" title="二十、从输入URL到页面加载发生了什么？"></a>二十、从输入URL到页面加载发生了什么？</h3><p>1、DNS解析</p><p>2、TCP连接</p><p>3、发送HTTP请求</p><p>4、服务器处理请求并返回HTTP报文</p><p>5、浏览器解析渲染页面</p><p>6、连接结束</p><h3 id="二十一、行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"><a href="#二十一、行内元素有哪些？块级元素有哪些？空（void）元素有哪些？" class="headerlink" title="二十一、行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"></a>二十一、行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行内元素有：a b span img input select strong</span><br><span class="line"></span><br><span class="line">块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</span><br><span class="line"></span><br><span class="line">空元素：&lt;br&gt;&lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</span><br></pre></td></tr></table></figure><h3 id="二十二、防抖和节流问题"><a href="#二十二、防抖和节流问题" class="headerlink" title="二十二、防抖和节流问题"></a>二十二、防抖和节流问题</h3><p>问题：一个事件被频繁的调用，会加重浏览器的负担，造成浏览器卡顿；</p><p>解决问题:可以使用==防抖和节流来解决==</p><p>==什么是防抖==：</p><p>（1）如果在200ms内没有再次触发滚动事件，那么就执行函数<br>（2）如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时</p><p><strong>效果</strong>：==如果短时间内大量触发同一事件，只会执行-一次函数。==</p><p><strong>实现：</strong>使用==setTimeOut定时器==</p><p><strong>代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay)&#123;</span><br><span class="line">    let timer &#x3D; null &#x2F;&#x2F;借助闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    timer &#x3D; setTimeout(fn,delay) &#x2F;&#x2F;简化写法</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;滚动事件</span><br><span class="line">function showTop() &#123;</span><br><span class="line">    var scrollTop &#x3D; document. body . scrollTop|| document.documentElement . scrollTop;</span><br><span class="line">    console.1og( &#39;滚动条位置: &#39; + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line">window.onscroll &#x3D; debounce(showTop ,1000)</span><br></pre></td></tr></table></figure><p>==什么是节流：==</p><p>类似控制阀门一样定期开放的函数,也就是让函数执行一次后,在某个时间段内暂时失效，过了这段时间后重新激活(类似于技能冷却时间)。</p><p>**效果:**如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</p><p><strong>实现：</strong>使用==setTimeOut定时器==</p><p><strong>代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay)&#123;</span><br><span class="line">    let valid &#x3D; true</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if(!valid)&#123;</span><br><span class="line">            &#x2F;&#x2F;休息时间暂不接客</span><br><span class="line">        return false </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;工作时间，执行函数并且在间隔朗内把状态位没为无效</span><br><span class="line"></span><br><span class="line">        valid &#x3D; false</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            fn()</span><br><span class="line">            valid &#x3D; true;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;滚动事件</span><br><span class="line">function showTop() &#123;</span><br><span class="line">    var scrollTop &#x3D; document. body . scrollTop|| document.documentElement . scrollTop;</span><br><span class="line">    console.1og( &#39;滚动条位置: &#39; + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line">window.onscroll &#x3D; debounce(showTop ,1000)</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><p>1.搜索框input事件,例如要支持输入实时搜索可以使用节流方案(间隔一段时间就必须查询相关内容)，或者实现输入间隔大于某个值(如500ms) ，就当做用户输入完成,然后开始搜索,具体使用哪种方案要看业务需求。<br>2.页面resize事件,常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染(这种情形一般是使用防抖, 因为只需要判断最后- -次的变化情况)</p><h3 id="二十三、（flex）弹性盒子的主轴和侧轴"><a href="#二十三、（flex）弹性盒子的主轴和侧轴" class="headerlink" title="二十三、（flex）弹性盒子的主轴和侧轴"></a>二十三、（flex）弹性盒子的主轴和侧轴</h3><p>弹性盒子分为==主轴==和==侧轴==（又称交叉轴）</p><p>属性：flex-direction </p><p>主轴设置：flex-direction ：row 或row-reverse </p><p>==主轴通俗来讲就是，X轴==</p><p>侧轴设置：flex-direction ：column  或column-reverse </p><p>==侧轴通俗来讲就是，y轴==</p><h3 id="二十四、同步异步的理解"><a href="#二十四、同步异步的理解" class="headerlink" title="二十四、同步异步的理解"></a>二十四、同步异步的理解</h3><p>==同步==：阻塞模式；==异步==：非阻塞模式</p><p>==同步==就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去； </p><p>==异步==是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。 </p><h3 id="二十五、Jq遍历方法有哪些"><a href="#二十五、Jq遍历方法有哪些" class="headerlink" title="二十五、Jq遍历方法有哪些"></a>二十五、Jq遍历方法有哪些</h3><h3 id="二十六、px、rem和em的区别"><a href="#二十六、px、rem和em的区别" class="headerlink" title="二十六、px、rem和em的区别"></a>二十六、px、rem和em的区别</h3><p>==px:== 绝对单位，页面按照精确像素展示</p><p>==em：==相对bai单位，基准点为==父节点==字体的大小，如果zhi自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p><p>==rem：==相对单位，可理解为”root em”, 相对==根节点==html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。</p><h3 id="二十六、call、apply和bind的区别"><a href="#二十六、call、apply和bind的区别" class="headerlink" title="二十六、call、apply和bind的区别"></a>二十六、call、apply和bind的区别</h3><p>==共同点：==call()、apply()和bind()都是改变函数内部的==this指向==，第一个参数也都放的是要改变this对象</p><p>==不同点：==</p><p>（1）主要在第二个参数上，==call()==从第二个开始放的是==正常的参数==，而==apply()==放的是==数组== ，==bind()==返回的是==函数==</p><p>（2）call()、apply()当第一个参数为 null、undefined的时候，默认指向window。 </p><p>（3）bind()不会立即执行，call()、apply()直接调用</p><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;有只猫叫小黑，小黑会吃鱼</span><br><span class="line">const cat &#x3D; &#123;</span><br><span class="line">    name :&#39;小黑&#39;，</span><br><span class="line">    eatFish(...args) &#123;</span><br><span class="line">        console. log(&#39;this指向&#x3D;&gt;&#39;，this);</span><br><span class="line">        console.1og(&#39;...args”，args);</span><br><span class="line">        console. log(this.name + &#39;吃鱼&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有只狗叫大毛，大毛会吃骨头</span><br><span class="line">const dog&#x3D;&#123;</span><br><span class="line">    name: &#39;大毛&#39;，</span><br><span class="line">    eatBone(...args) &#123;</span><br><span class="line">        console. log(&#39;this指向&#x3D;&gt;&#39;，this);</span><br><span class="line">        console.1og(&#39;...args”, args);</span><br><span class="line">        console. log(this.name + &#39;吃骨头&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">console.1og(&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; call &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;);</span><br><span class="line">    &#x2F;&#x2F;有一天大毛想吃鱼了，可是它不知道怎么吃。怎么办?小黑说我吃的时候喂你吃</span><br><span class="line">    cat.eatFish.call(dog, &#39;汪汪汪’， &#39;call&#39;)</span><br><span class="line">    &#x2F;&#x2F;大毛为了表示感谢，决定下次吃骨头的时候也喂小黑吃</span><br><span class="line">    dog.eatBone.call(cat,&#39;喵喵喵 &#39;，&#39;call&#39;)</span><br><span class="line">console.1og(&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; apply &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;);</span><br><span class="line">    cat.eatFish.apply(dog, [汪汪汪&#39;，&#39; apply&#39;])</span><br><span class="line">    dog.eatBone.apply(cat, [&#39;喵喵喵&#39;，&#39; apply&#39;])</span><br><span class="line">console.1og(&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; bind &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;);</span><br><span class="line">&#x2F;&#x2F;有一天他们觉得每次吃的时候再暧太麻烦了。于脆直接教对方怎么吃</span><br><span class="line">    const test1 &#x3D; cat.eatFish.bind(dog,汪汪汪’， &#39; bind&#39;)</span><br><span class="line">    const test2 &#x3D; dog. eatBone.bind(cat, &#39;喵喵喵’， &#39; bind&#39;)</span><br><span class="line">    test1()</span><br><span class="line">    test2()</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><p>1.求数组中的最大和最小值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3, 89, 46]; </span><br><span class="line">var max &#x3D; Math.max.apply(null, arr);  &#x2F;&#x2F; 89</span><br><span class="line">var min &#x3D; Math.min.apply(null, arr); &#x2F;&#x2F; 1 </span><br></pre></td></tr></table></figure><p>2.将类数组转为数组 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var trueArr &#x3D; Array.prototype.slice.call( arrayLike ); </span><br></pre></td></tr></table></figure><p>3.数组追加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1, 2, 3]; </span><br><span class="line">var arr2 &#x3D; [4, 5, 6]; </span><br><span class="line">var total &#x3D; [].push.apply(arr1, arr2);  &#x2F;&#x2F; 6 </span><br><span class="line">arr1 &#x3D; [1, 2, 3, 4, 5, 6]</span><br><span class="line">arr2 &#x3D; [4, 5, 6]</span><br></pre></td></tr></table></figure><p>4.判断变量类型 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isArray(obj)&#123;     </span><br><span class="line">    return Object.prototype.toString.call(obj) &#x3D;&#x3D; &#39;[Object Array]&#39;; </span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; isArray([])  &#x3D;&gt; true </span><br><span class="line">&#x2F;&#x2F; isArray(&#39;yw&#39;) &#x3D;&gt; false </span><br></pre></td></tr></table></figure><p>5.利用call和apply做继承 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fucntion Person(name, age)&#123;     </span><br><span class="line">&#x2F;&#x2F; 这里的this都指向实例    </span><br><span class="line">this.name &#x3D; name;     </span><br><span class="line">this.age &#x3D; age;     </span><br><span class="line">this.sayAge &#x3D; function()&#123;        </span><br><span class="line">     console.log(this.age)     </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">function Female()&#123;     </span><br><span class="line">    Person.apply(this, arguments); &#x2F;&#x2F; 将父元素所有方法在这里执行一遍就继承了 </span><br><span class="line">&#125; </span><br><span class="line">var female &#x3D; new Female(&#39;yw&#39;, 27); </span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>1.当我们使用-个函数需要改变this指向的时候才会用到call apply bind<br>2.如果你要传递的参数不多,则可以使用fn.call(thisobj, arg1, arg2 …）<br>3.如果你要传递的参数很多，则可以用数组将参数整理好调用fn. apply(this0bj, [arg1, arg2 …)<br>4.如果你想生成一个新的函数长期绑定某 个函数给某个对象使用，则可以使用const newFn =<br>fn. bind(this0bj); newFn(arg1, arg2…)</p><h3 id="二十七、原型链和原型"><a href="#二十七、原型链和原型" class="headerlink" title="二十七、原型链和原型"></a>二十七、原型链和原型</h3><p><strong>1.原型链的概念</strong>：</p><p><strong>2.原型的概念：</strong>原型是一个对象</p><h3 id="二十八、面向对象和面向过程的区别"><a href="#二十八、面向对象和面向过程的区别" class="headerlink" title="二十八、面向对象和面向过程的区别"></a>二十八、面向对象和面向过程的区别</h3><p><strong>面向过程：</strong>是按一定的顺序来执行</p><p><strong>面向对象：</strong>思维方式 找到角色，确定职责</p><h3 id="二十九、this-的指向"><a href="#二十九、this-的指向" class="headerlink" title="二十九、this.的指向"></a>二十九、this.的指向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ele.onclick &#x3D; function()&#123;</span><br><span class="line">    console.log(this)  &#x2F;&#x2F;this指向ele</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this指向【当前对象】，所谓的当前对象，是指，此刻正在执行这个函数的对象，谁调用这个函数，this就指向谁</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D; Person();</span><br><span class="line"></span><br><span class="line">let obj &#x3D;&#123;</span><br><span class="line">    print : Person</span><br><span class="line">&#125;</span><br><span class="line">obj.print &#x3D;&#x3D; person;</span><br><span class="line">window.Person();&#x2F;&#x2F;此时this指向widow</span><br><span class="line">obj.print();&#x2F;&#x2F;此时this指向obj</span><br><span class="line"></span><br><span class="line">setInterval(Person,200); &#x2F;&#x2F;此时this指向widow</span><br><span class="line"></span><br><span class="line">对象.方法();</span><br><span class="line"></span><br><span class="line">Person.call(document)； 等价于document.Person()</span><br><span class="line">方法.call(对象)</span><br><span class="line"></span><br><span class="line">call&#x2F;apply </span><br><span class="line">函数.call(指定任何对象)；&#x2F;&#x2F;可以直接执行函数</span><br><span class="line">let 新函数 &#x3D; 函数.bind(obj);</span><br><span class="line">新函数的this,会永久的指向obj,因此我们说，this被绑定了</span><br><span class="line"></span><br><span class="line">手动实现一个bind方法</span><br><span class="line">Function.prototype.bind &#x3D; function(target)&#123;</span><br><span class="line">    var fn &#x3D; this;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        fn.apply(target,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newalert &#x3D; alert.bind(xxx);</span><br></pre></td></tr></table></figure><h3 id="三十、箭头函数的this"><a href="#三十、箭头函数的this" class="headerlink" title="三十、箭头函数的this"></a>三十、箭头函数的this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D;&#123;</span><br><span class="line">    id:99,</span><br><span class="line">    hello:()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(this); &#x2F;&#x2F;指向window  诀窍：当这个箭头函数不存在</span><br><span class="line">        console.log(this.id)； &#x2F;&#x2F;undefined</span><br><span class="line">    &#125;</span><br><span class="line">    obj.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三十一、几种常见的隐藏元素的方法"><a href="#三十一、几种常见的隐藏元素的方法" class="headerlink" title="三十一、几种常见的隐藏元素的方法"></a>三十一、几种常见的隐藏元素的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a. visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。</span><br><span class="line"></span><br><span class="line">b. opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate</span><br><span class="line"></span><br><span class="line">c. position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。</span><br><span class="line"></span><br><span class="line">d. display: none；元素会变得不可见，并且不会再占用文档的空间</span><br><span class="line">e. transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。</span><br></pre></td></tr></table></figure><h3 id="三十二、几种可以清除浮动的方法"><a href="#三十二、几种可以清除浮动的方法" class="headerlink" title="三十二、几种可以清除浮动的方法"></a>三十二、几种可以清除浮动的方法</h3><p>a. 添加额外标签，例如<code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code> </p><p>b. 父元素设置 overflow：hidden；在IE6中还需要触发<a href="http://yiminghe.iteye.com/blog/367384">hasLayout</a>，例如zoom：1；</p><p>c. 父元素设置 overflow：auto 属性；同样IE6需要触发hasLayout </p><p>d. 使用:after 伪元素；由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">     content: &quot;&quot;; </span><br><span class="line">     display: block; </span><br><span class="line">     height: 0; </span><br><span class="line">     clear: both; </span><br><span class="line">     visibility: hidden;  </span><br><span class="line">     zoom:1 &#x2F;&#x2F;为了兼容IE6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三十三、table布局的缺点"><a href="#三十三、table布局的缺点" class="headerlink" title="三十三、table布局的缺点"></a>三十三、table布局的缺点</h3><p>a. 太深的嵌套，比如table&gt;tr&gt;td&gt;h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量。</p><p>b. 灵活性差，比如要将tr设置border等属性，是不行的，得通过td</p><p>c. 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱</p><p>d. 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱。</p><p>e. table需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。</p><p>f. 不够语义</p><h3 id="三十四、对盒模型和怪异盒模型的理解"><a href="#三十四、对盒模型和怪异盒模型的理解" class="headerlink" title="三十四、对盒模型和怪异盒模型的理解"></a>三十四、对盒模型和怪异盒模型的理解</h3><p>==盒模型==：在W3S标准中，一个盒子的高度和宽度，指的是元素的==真实宽度和高度==</p><p>==怪异盒模型：==在IE下一个盒子的高度和宽度，指的是还==包括padding和border==</p><p>==content-box：== padding和border==不被包含==在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。（W3C盒子模型）</p><p>==border-box：== padding和border被==包含==在定义的width和height之内。对象的实际宽度就等于设置的width值。（IE6盒子模型）</p><h3 id="三十五、HTML5有哪些新特性"><a href="#三十五、HTML5有哪些新特性" class="headerlink" title="三十五、HTML5有哪些新特性"></a>三十五、HTML5有哪些新特性</h3><p>a. HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p><p>b. 拖拽释放(Drag and drop) API</p><p>c. 语义化更好的内容标签（header,nav,footer,aside,article,section）</p><p>d. 音频、视频(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio">audio</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">video</a>)API</p><p>e. 画布(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">Canvas</a>) API</p><p>f. 地理(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/Using_geolocation">Geolocation</a>) API</p><p>g. 本地离线存储 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage">localStorage</a> 长期存储数据，浏览器关闭后数据不丢失</p><p>h. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage">sessionStorage</a> 的数据在页面会话结束时会被清除</p><p>i. 表单控件，calendar、date、time、email、url、search </p><p>j. 新的技术<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">webworker</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">websocket</a>等</p><h3 id="三十六、CSS3有哪些新特性"><a href="#三十六、CSS3有哪些新特性" class="headerlink" title="三十六、CSS3有哪些新特性"></a>三十六、CSS3有哪些新特性</h3><p>CSS3实现圆角（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">border-radius</a>），阴影（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow">box-shadow</a>），对文字加特效（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">text-shadow</a>），线性渐变（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient">gradient</a>），变形（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">transform</a>）</p><p>增加了更多的CSS选择器  多背景 rgba，在CSS3中唯一引入的伪元素是::selection，媒体查询，多栏布局</p><h3 id="三十七、JavaScript-的同源策略-的理解"><a href="#三十七、JavaScript-的同源策略-的理解" class="headerlink" title="三十七、JavaScript 的同源策略 的理解"></a>三十七、JavaScript 的同源策略 的理解</h3><p>同源策略指的是：==协议== ，==域名== ，==端口== 相同，同源策略是一种安全协议。</p><p>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><h3 id="三十八、rgba-和opacity的透明效果有什么不同？"><a href="#三十八、rgba-和opacity的透明效果有什么不同？" class="headerlink" title="三十八、rgba()和opacity的透明效果有什么不同？"></a>三十八、rgba()和opacity的透明效果有什么不同？</h3><p>a. opacity作用于元素，以及元素内的所有内容的透明度，rgba()只作用于元素的颜色或其背景色。</p><p>b. 设置rgba透明的元素的子元素不会继承透明效果！</p><h3 id="三十九、实现预加载一张图片，加载完成后显示在网页中并设定其高度为50px，宽度为50px"><a href="#三十九、实现预加载一张图片，加载完成后显示在网页中并设定其高度为50px，宽度为50px" class="headerlink" title="三十九、实现预加载一张图片，加载完成后显示在网页中并设定其高度为50px，宽度为50px"></a>三十九、<strong>实现预加载一张图片，加载完成后显示在网页中并设定其高度为50px，宽度为50px</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    img &#x3D; new Image();</span><br><span class="line">    img.src &#x3D; &quot;http:&#x2F;&#x2F;pic8.nipic.com&#x2F;20100701&#x2F;5290458_114840036316_2.jpg&quot;;</span><br><span class="line">    img.onload &#x3D; function () &#123;</span><br><span class="line">        img.height &#x3D; 50;</span><br><span class="line">        img.width &#x3D; 50;</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.appendChild(img);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="四十、使用原生js写一个深度克隆一个对象"><a href="#四十、使用原生js写一个深度克隆一个对象" class="headerlink" title="四十、使用原生js写一个深度克隆一个对象"></a>四十、使用原生js写一个深度克隆一个对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var cloneObj &#x3D; function (obj) &#123;</span><br><span class="line">        var str, newobj &#x3D; obj.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;;</span><br><span class="line">        if (typeof obj !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (window.JSON) &#123;</span><br><span class="line">            str &#x3D; JSON.stringify(obj), &#x2F;&#x2F;系列化对象</span><br><span class="line">                newobj &#x3D; JSON.parse(str); &#x2F;&#x2F;还原</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (var i in obj) &#123;</span><br><span class="line">                newobj[i] &#x3D; typeof obj[i] &#x3D;&#x3D;&#x3D; &#39;object&#39; ?</span><br><span class="line">                    cloneObj(obj[i]) : obj[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newobj;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;测试</span><br><span class="line">    var obj &#x3D; &#123; a: 0, b: 1, c: 2 &#125;;</span><br><span class="line">    var arr &#x3D; [0, 1, 2];</span><br><span class="line">    &#x2F;&#x2F;执行深度克隆</span><br><span class="line">    var newobj &#x3D; cloneObj(obj);</span><br><span class="line">    var newarr &#x3D; cloneObj(arr);</span><br><span class="line">    &#x2F;&#x2F;对克隆后的新对象进行成员删除</span><br><span class="line">    delete newobj.a;</span><br><span class="line">    newarr.splice(0, 1);</span><br><span class="line">    console.log(obj);</span><br><span class="line">    console.log(arr);</span><br><span class="line">    console.log(newobj);</span><br><span class="line">    console.log(newarr);</span><br><span class="line"></span><br><span class="line">    var it &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F;var newit &#x3D; cloneObj(newit);</span><br><span class="line">    &#x2F;&#x2F;console.log(newit);</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="四十一、JS如何实现面向对象和继承机制？"><a href="#四十一、JS如何实现面向对象和继承机制？" class="headerlink" title="四十一、JS如何实现面向对象和继承机制？"></a>四十一、JS如何实现面向对象和继承机制？</h3><p><strong>创建对象方法：</strong></p><p>a. 利用json创建对象</p><p>b. 使用JavaScript中的Object类型</p><p>c. 通过创建函数来生成对象</p><p><strong>继承机制：</strong></p><p>a. 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上</p><p>b. prototype模式，继承new函数的模式</p><p>c. 直接继承函数的prototype属性，对b的一种改进</p><p>d. 利用空对象作为中介</p><p>e. 在ECMAScript5中定义了一个新方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a>，用于创建一个新方法</p><p>f. 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。 </p><h3 id="四十二、jQuery的特点"><a href="#四十二、jQuery的特点" class="headerlink" title="四十二、jQuery的特点"></a>四十二、jQuery的特点</h3><p>a. 一款轻量级的js库</p><p>b. 丰富快速的DOM选择器</p><p>c. 链式表达式</p><p>d. 事件、样式、动画等特效支持</p><p>e. Ajax操作封装，支持跨域</p><p>f. 跨浏览器兼容</p><p>g. 插件扩展开发</p><h3 id="四十三、Ajax有哪些好处和弊端？"><a href="#四十三、Ajax有哪些好处和弊端？" class="headerlink" title="四十三、Ajax有哪些好处和弊端？"></a>四十三、Ajax有哪些好处和弊端？</h3><p><strong>优点：</strong></p><p>a. 无刷新更新数据</p><p>b. 异步与服务器通信</p><p>c. 前端和后端负载平衡</p><p>d. 基于标准被广泛支持</p><p>e. 界面与应用分离</p><p><strong>缺点：</strong></p><p>a. AJAX干掉了Back和History功能，即对浏览器机制的破坏</p><p>b. AJAX的安全问题</p><p>c. 对搜索引擎支持较弱</p><p>d. 违背URL和资源定位的初衷</p><h3 id="四十四、null和undefined的区别？"><a href="#四十四、null和undefined的区别？" class="headerlink" title="四十四、null和undefined的区别？"></a>四十四、null和undefined的区别？</h3><p><strong>null：</strong></p><p>a. null是一个表示”无”的对象，转为数值时为0</p><p>b. null表示”没有对象”，即该处不应该有值。</p><p><strong>undefined：</strong></p><p>a. undefined是一个表示”无”的原始值，转为数值时为NaN。</p><p>b. undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p><h3 id="四十五、new操作符具体干了什么呢"><a href="#四十五、new操作符具体干了什么呢" class="headerlink" title="四十五、new操作符具体干了什么呢?"></a>四十五、new操作符具体干了什么呢?</h3><p>a. 一个新对象被创建。它继承自函数原型</p><p>b. 构造函数被执行。执行的时候，相应的传参会被传入</p><p>c. 上下文(this)会被指定为这个新实例</p><p>d. 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果</p><h3 id="四十六、JS异步编程方式有几种？"><a href="#四十六、JS异步编程方式有几种？" class="headerlink" title="四十六、JS异步编程方式有几种？"></a>四十六、JS异步编程方式有几种？</h3><p>a. 回调函数</p><p>b. 事件监听</p><p>c. 发布订阅</p><p>d. promise </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础篇</title>
      <link href="/2020/080816107.html"/>
      <url>/2020/080816107.html</url>
      
        <content type="html"><![CDATA[<p>基础篇</p><h4 id="1-Js有哪些数据类型"><a href="#1-Js有哪些数据类型" class="headerlink" title="1.Js有哪些数据类型"></a>1.Js有哪些数据类型</h4><p>Number 数字类型</p><p>String 字符串类型</p><p>Boolean 布尔类型</p><p>Null 空</p><p>Undefined 未定义</p><p>Object 对象{function，Array,Date}</p><p>Symbol  es6</p><h4 id="2-js验证数据类型"><a href="#2-js验证数据类型" class="headerlink" title="2.js验证数据类型"></a>2.js验证数据类型</h4><p>typeof 除了null都可以显示正确的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof undefined);&#x2F;&#x2F;undefined</span><br><span class="line">console.log(typeof 123);&#x2F;&#x2F; number</span><br><span class="line">console.log(typeof &#39;123&#39;);&#x2F;&#x2F;string</span><br><span class="line">console.log(typeof true);  &#x2F;&#x2F; boolean</span><br><span class="line">console.log(typeof [1,2,3]);&#x2F;&#x2F;object数组的数据类型在typeof中被解释为object</span><br><span class="line">console.log(typeof &#123;&quot;id&quot;: 11&#125;); &#x2F;&#x2F;object</span><br><span class="line">lconsole.log(typeof null); &#x2F;&#x2F;object</span><br><span class="line">console.log(typeof console.log);&#x2F;&#x2F;function </span><br></pre></td></tr></table></figure><p>instanceof 可以正确的判断对象的类型，因为instanceof是通过判断对象的原型链是不是能找到类型的prototype</p><p>instanceof 能准确的判断引用数据类型（Array，function，Object）,却不能判断基本数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(2 instanceof Number)                &#x2F;&#x2F;false</span><br><span class="line">console.log(true instanceof Boolean)         &#x2F;&#x2F;false</span><br><span class="line">console.log( &#39;str&#39; instanceof String);         &#x2F;&#x2F;false</span><br><span class="line">console.log([] instanceof Array );             &#x2F;&#x2F;true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function);  &#x2F;&#x2F;true</span><br><span class="line">console.log(&#123;&#125;instanceof Object);            &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h4 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h4><p>toSring（）//转换string</p><p>Number() 、parseFloat()、parseInt()//转换为number</p><p>Boolean() //转换boolean类型</p><h4 id="4-JSON"><a href="#4-JSON" class="headerlink" title="4.JSON"></a>4.JSON</h4><p>JSON是js的一个对象，也是一种数据格式，JSON的两个api</p><p>（1）   将JSON字符串转换成JSON对象 JSON.parse（）</p><p>（2）   将JSON对象转换成JSON字符串JSON.stringify()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SON字符串</span><br><span class="line">var str1 &#x3D;&#39;&#123;&quot;name&quot; : &quot;]avaScript&quot;, &quot;age&quot;: &quot;24&quot;〕&#39;</span><br><span class="line"></span><br><span class="line">SON对象</span><br><span class="line">var str2 &#x3D; &#123;name: &quot;avaScript&quot;, age: &quot;24&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-js数组方法"><a href="#5-js数组方法" class="headerlink" title="5.js数组方法"></a>5.js数组方法</h4><p>（1）join()拼接 ，数组转化为字符串</p><p>（2）split（）//字符串切割成数字</p><p>（3）reverse() //数组元素颠倒顺序，翻转</p><p>（4）concat() //数组拼接</p><p>（5）slice()//截取数组，字符串拼接数组</p><p>（6）splice()//从数组中删除</p><p>（7）push()//在数组中尾部添加一个或多个元素</p><p>（8）pop()//从数组尾部删除一个元素</p><p>（9）unshift()//从数组开始位置添加一个元素或多个元素</p><p>（10）shift()//从数组开始位置删除一个元素</p><p>（11）toString（）转换为字符串</p><p>（12）indexOf()查找起点位置索引</p><p>（13）sort()排序</p><p>（14）forEach()从头至尾遍历数组</p><p>（15）map()调用数组</p><p>（16）filter()过滤</p><p>（17）every（）所有满足条件 返回true和some() 一项条件满足返回true</p><p>（18）reduce()函数和递归的初始值</p><p>（19）str.padStart(targetlenght,padsting)</p><p> str.padEnd(targetlenght，padsting)</p><p>targetLength</p><p>　　当前字符串需要补全的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p><p>padString | 可选</p><p>　　补全字符串。如果字符串太长，使补全的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为“” （U+0020）</p><p><strong>padStart()</strong> <strong>方法用另一个字符串填充当前字符串（重复，如果需要的话），以便产生的字符串达到给定的长度。填充从当前字符串的开始（左侧）应用的。padEnd() 填充从当前字符串的末尾（右侧）应用的。</strong></p><p><strong>Eg:</strong> <code>&#39;wen&#39;.padStart(5, &#39;12&#39;)  //  &#39;12Wen&#39;</code></p><p><code>&#39;wen&#39;.padEnd(2, &#39;ab&#39;) // &#39;wen&#39;</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
